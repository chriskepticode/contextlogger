// Â© 2016-2017 Helix OpCo LLC. All rights reserved.
// Initial Author: Chris Williams

/*
This extracts merry Values into logger Fields, then passes along to the base logger
*/
package merry

import (
	"github.com/ansel1/merry"

	"github.com/myhelix/contextlogger/log"
	"github.com/myhelix/contextlogger/providers"

	"context"
	"fmt"
	"regexp"
	"runtime"
)

type provider struct {
	config       *Config
	nextProvider providers.LogProvider
}

type Config struct {
	// Ignore these stack frames for purposes of reportedAt
	IgnoreStackFrames *regexp.Regexp
}

var RecommendedConfig = Config{
	IgnoreStackFrames: regexp.MustCompile("myhelix/log|<autogenerated>"),
}

func LogProvider(nextProvider providers.LogProvider, config Config) (providers.LogProvider, merry.Error) {
	if nextProvider == nil {
		return nil, merry.New("Merry log provider requires a base provider")
	}
	return provider{&config, nextProvider}, nil
}

// If our list of arbitrary things is actually one error, return that error
func (p provider) listOfOneError(errs []interface{}) error {
	if len(errs) == 1 {
		if err, ok := errs[0].(error); ok {
			pc := make([]uintptr, 50)
			runtime.Callers(1, pc)
			for _, frame := range pc {
				frameData := runtime.FuncForPC(frame)
				file, line := frameData.FileLine(frame)
				if p.config.IgnoreStackFrames == nil || p.config.IgnoreStackFrames.MatchString(file) {
					return merry.WithValue(err, "reportedAt", fmt.Sprintf("%s:%d", file, line))
				}
			}
			// We should never get here normally, but just in case; e.g. errors reported from this file
			return err
		}
	}
	return nil
}

// Extract fields from merry error values if input was exactly one error
func (p provider) extractFields(args []interface{}) (fields log.Fields) {
	fields = make(log.Fields)
	if err := p.listOfOneError(args); err != nil {
		for key, val := range merry.Values(err) {
			if key, ok := key.(string); ok {
				switch key {
				case "stack", "message":
					// Merry built-ins; ignore
				default:
					fields[key] = val
				}
			}
		}
	}
	return
}

// We always extract merry Values from an error, but only for Error level do we print a traceback
func (p provider) Error(ctx context.Context, report bool, args ...interface{}) {
	if err := p.listOfOneError(args); err != nil {
		args = []interface{}{merry.Details(err)}
	}
	p.nextProvider.Error(log.ContextWithFields(ctx, p.extractFields(args)), report, args...)
}

func (p provider) Warn(ctx context.Context, report bool, args ...interface{}) {
	p.nextProvider.Warn(log.ContextWithFields(ctx, p.extractFields(args)), report, args...)
}

func (p provider) Info(ctx context.Context, report bool, args ...interface{}) {
	p.nextProvider.Info(log.ContextWithFields(ctx, p.extractFields(args)), report, args...)
}

func (p provider) Debug(ctx context.Context, report bool, args ...interface{}) {
	p.nextProvider.Debug(log.ContextWithFields(ctx, p.extractFields(args)), report, args...)
}

func (p provider) Record(ctx context.Context, metrics map[string]interface{}) {
	p.nextProvider.Record(ctx, metrics)
}

func (p provider) RecordEvent(ctx context.Context, eventName string, metrics map[string]interface{}) {
	p.nextProvider.RecordEvent(ctx, eventName, metrics)
}

func (p provider) Wait() {
	p.nextProvider.Wait()
}
